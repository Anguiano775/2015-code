#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, dgtl1,  readyLED,       sensorLEDtoVCC)
#pragma config(Sensor, I2C_1,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_2,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_3,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_4,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Motor,  port1,           intake1,       tmotorVex393_HBridge, openLoop)
#pragma config(Motor,  port2,           Fly1,          tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port3,           Fly2,          tmotorVex393_MC29, openLoop, encoderPort, I2C_1)
#pragma config(Motor,  port4,           Fly3,          tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port5,           rightDrive,    tmotorVex393_MC29, openLoop, encoderPort, I2C_4)
#pragma config(Motor,  port6,           leftDrive,     tmotorVex393_MC29, openLoop, reversed, encoderPort, I2C_3)
#pragma config(Motor,  port7,           Fly4,          tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port8,           Fly5,          tmotorVex393_MC29, openLoop, encoderPort, I2C_2)
#pragma config(Motor,  port9,           Fly6,          tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port10,          intake2,       tmotorVex393_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//constants
float LCLICKS_PER_REV = 606; //default = 627.2 for IME, 360 for quadrature encoders
float RCLICKS_PER_REV = 624;
//float CLICKS_PER_METER = ;
bool flywheelRunning = false; //global variable to keep track of flywheel status - this will allow us to prevent the acceleration function from being called more than once


void setLeftSpeed (float speed) //sets speed of left flywheel
{
	motor[Fly1] = speed;
	motor[Fly2] = speed;
	motor[Fly3] = speed;
}

void setRightSpeed (float speed) //sets speed of right flywheel
{
	motor[Fly4] = speed;
	motor[Fly5] = speed;
	motor[Fly6] = speed;
}

float rpmToMotorPower (float rpm) { //function to convert RPM values to a motor power; for flywheel acceleration function to convert a starting RPM to an initial motor power
	return rpm/100*127; //reverse of calculation for motor speed to RPM
}

//check if both RPMs are in the range required to make a shot
void checkLED (float lRPM, float rRPM) {
	if (lRPM >= 88 && lRPM <= 91 && rRPM >= 79 && rRPM <= 82) {
		SensorValue[readyLED] = true; //turn on the ready (green LED)
	}
}


void accelerateFlyWheel (float targetSpeed) //gradually increases speed of flywheel
{
	flywheelRunning = true;
	clearTimer(T1);
	bool accelerateOn = true;
	float leftEncVal;
	float rightEncVal;
	float leftRPM;
	float rightRPM;
	float lSpeed;
	float rSpeed;
	float targetlRPM = (lSpeed/127*100); //convert motor speed to RPM target - RPM must meet this in order for the acceleration to continue to the next stage
	float targetrRPM = (rSpeed/127*100);
	bool lAtTarget = false;
	bool rAtTarget = false;
	float calcSpeed;
	float accelSpeed;
	//accelerateOn = (vexRT[Btn5D] == 1) ? true : false; //use joystick button to control acceleration (turn flywheels on/off)
	accelerateOn=true;
	clearLCDLine(0);
	clearLCDLine(1);
	displayLCDString(0, 0, "L: ");
	displayLCDString(1, 0, "R: ");

	//get an initial RPM estimate so that if the flywheel has already been started, the acceleration process can continue there; we can't use a variable for this because the flywheel will decelerate as soon as it is no longer receiving power
	nMotorEncoder[Fly2] = 0;
	nMotorEncoder[Fly5] = 0;
	wait1Msec(250); //250ms data capture period
	leftEncVal = abs(nMotorEncoder[Fly2]); //record the distance recorded by the encoder in the 500 ms period; take the absolute value so counting direction is irrelevant
	rightEncVal = abs(nMotorEncoder[Fly5]);

	//approximate flywheel RPM values using the encoder readings
	leftRPM = (leftEncVal/LCLICKS_PER_REV*240); //dimensional analysis to convert encoder values to RPM using values for the motors we're using		rightRPM = (rightEncVal/RCLICKS_PER_REV*240)/7;
	rightRPM = (rightEncVal/RCLICKS_PER_REV*240);
	//writeDebugStreamLine("Estimated starting left RPM is %d for target %d",leftRPM,lSpeed);
	//writeDebugStreamLine("Estimated starting right RPM is %d for target %d",rightRPM,rSpeed);

	float lRawSpeed = rpmToMotorPower(leftRPM);
	float rRawSpeed = rpmToMotorPower(rightRPM);

	if(lRawSpeed >= 30) { //check if rawSpeed is greater than the mininum required speed to start the flywheel of 25
	lSpeed = lRawSpeed - floor(lRawSpeed) > .5 ? ceil(lRawSpeed) : floor(lRawSpeed); //round the raw speed to the nearest integer to make calculations a little simpler
	}
	else {
		lSpeed = 30;
	}

	if(rRawSpeed >= 40) { //check if rawSpeed is greater than the mininum required speed to start the flywheel of 25
	rSpeed = rRawSpeed - floor(rRawSpeed) > .5 ? ceil(rRawSpeed) : floor(rRawSpeed);  //round the raw speed to the nearest integer to make calculations a little simpler
	}
	else {
		rSpeed = 40;
	}

	while(accelerateOn) { //the outer while loop ensures that flywheels continue running once they are up to speed

		while((!lAtTarget || !rAtTarget) && accelerateOn) //only accelerate if the appropriate button on the joystick is pressed and at least one side is not up to speed
		{
			//accelerateOn = (vexRT[Btn5D] == 1) ? true : false; //use joystick button to control acceleration (turn flywheels on/off)
			setLeftSpeed(lSpeed); //set flywheel speed to latest calculated value
			setRightSpeed(rSpeed);

			//determine how far each side of the flywheel has traveled in 1 sec, so we can approximate RPM
			nMotorEncoder[Fly2] = 0;
			nMotorEncoder[Fly5] = 0;
			wait1Msec(250); //250ms data capture period
			leftEncVal = abs(nMotorEncoder[Fly2]); //record the distance recorded by the encoder in the 500 ms period; take the absolute value so counting direction is irrelevant
			rightEncVal = abs(nMotorEncoder[Fly5]);

			//approximate flywheel RPM values using the encoder readings
			leftRPM = (leftEncVal/LCLICKS_PER_REV*240); //dimensional analysis to convert encoder values to RPM using values for the motors we're using
			rightRPM = (rightEncVal/RCLICKS_PER_REV*240);
			writeDebugStreamLine("L: %d R: %d",leftRPM,rightRPM);
			checkLED(leftRPM,rightRPM); //if current RPM values are in range, the LED will turn on; the placement of this function call should be pretty good because if the RPM is within range, the flywheels shouldn't be adjusting much

			//change motor speed as needed for each side
			if(leftRPM >= targetlRPM && lSpeed < targetSpeed) //if the left side is done accelerating from previous loop and is below target speed
			{
				calcSpeed = ((targetSpeed-(lSpeed))/targetSpeed)*20;
			accelSpeed = calcSpeed > 7 ? calcSpeed : 7;
				lSpeed += calcSpeed; //increase the target speed - either by 5 or the difference between the current and the target speeds
				targetlRPM = lSpeed/127*100; //calculate new target RPM
				//writeDebugStreamLine("Calculated new goal RPM value for left side: %d for speed %d",targetlRPM,lSpeed);
			}
			else if(lSpeed == targetSpeed){
				lAtTarget = true; //left flywheel up to speed
				//writeDebugStreamLine("Left side reached target");
			}

			if(rightRPM >= targetrRPM  && rSpeed < targetSpeed) //if the right side is done accelerating from previous loop and is below target speed
			{
				calcSpeed = ((targetSpeed-(rSpeed))/targetSpeed)*20;
			accelSpeed = calcSpeed > 8 ? calcSpeed : 8;
				rSpeed += calcSpeed; //increase the target speed - either by 5 or the difference between the current and the target speeds
				targetrRPM = rSpeed/127*100; //calculate new target RPM
				//writeDebugStreamLine("Calculated goal RPM value for right side: %d for speed %d",targetrRPM,rSpeed);
			}
			else if (rSpeed == targetSpeed) {
				rAtTarget = true;
				//writeDebugStreamLine("Right side reached target");
			}
			if(vexRT[Btn7D] == 1 && vexRT[Btn8D] == 1) { //stop accelerating if the button is released and reset variables
				accelerateOn = false;
				flywheelRunning = false;
				setLeftSpeed(0);
				setRightSpeed(0);
			}

		}
		displayLCDCenteredString(0, "Done");
	}

}

task accelerate() {
	while(1)
	{
		if(vexRT[Btn5D] == 1 && !flywheelRunning)
		{
			accelerateFlyWheel(90);
		}
		//no else statement needed because the acceleration code looks for when it needs to stop itself
	}
}
task main()
{
	bool useAcceleration = true; //TESTING ONLY. to test flywheel without acceleration
	if (useAcceleration)
	{
		startTask(accelerate); //starts the flywheel movement code
	}
	clearLCDLine(0);
	clearLCDLine(1);
	bLCDBacklight = true;
	int direction;

	while(true)
	{
		direction = vexRT[Btn7U] == 1 ? -1 : 1; //set intake direction
		//motor[leftDrive] = vexRT[Ch3];
		//motor[rightDrive] = vexRT[Ch2];

		if(vexRT[Btn5D] == 1 && !useAcceleration) {
			setLeftSpeed(90);
			setRightSpeed(90);
		}
		else if(!useAcceleration)
		{
			setLeftSpeed(0);
			setRightSpeed(0);
		}
	motor[intake1] = vexRT[Btn6U] == 1 ? 125*direction : 0;
	motor[intake2] = vexRT[Btn6D] == 1 ? -125*direction : 0;
	}
}
