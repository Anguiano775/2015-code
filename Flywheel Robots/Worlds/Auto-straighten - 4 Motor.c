#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in1,    gyro,           sensorGyro)
#pragma config(Sensor, I2C_3,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_4,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_5,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port3,           intake,        tmotorVex393HighSpeed_MC29, openLoop, encoderPort, I2C_3)
#pragma config(Motor,  port4,           rDriveFront,   tmotorVex393HighSpeed_MC29, openLoop, encoderPort, I2C_4)
#pragma config(Motor,  port5,           rDriveBack,    tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port6,           lDriveBack,    tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port7,           lDriveFront,   tmotorVex393HighSpeed_MC29, openLoop, reversed, encoderPort, I2C_5)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

void setLDriveMotors(float power) {
	motor[lDriveFront] = power;
	motor[lDriveBack] = power;
}

void setRDriveMotors(float power) {
	motor[rDriveFront] = power;
	motor[rDriveBack] = power;
}

bool userDriveControl = true;
float straighteningKpLeft = 0.2, //proportional constant for straightening response for the left side
straighteningKpRight = 0.2; //proportional constant for straightening response for the right side

task autostraighten() {
	while(1) {
	if(vexRT[Ch3] >= 120 && vexRT[Ch2] >= 120) { //if the user is going about full speed and nearly straight
		userDriveControl = false; //disable user drivetrain control so we can auto-straighten

		//reset encoders
		nMotorEncoder[rDriveFront] = 0;
		nMotorEncoder[lDriveFront] = 0;

		int straighteningError,
		slewRateLimit = 15;
		float	power = 127,
		lPower,
		rPower,
		lPowerLast = vexRT[Ch3], //set the initial last power values to whatever the joystick is when auto-straighten is activated
		rPowerLast = vexRT[Ch2];

		//adjust the powers sent to each side if the encoder values don't match
		straighteningError = nMotorEncoder[lDriveFront] - nMotorEncoder[rDriveFront];

		if (straighteningError > 0) { //left side is ahead, so speed up the right side or slow down the left side
			rPower = power + straighteningError*straighteningKpLeft;
			if (rPower > 127) { //if the correction we would apply
				rPower = rPowerLast;
				lPower = power - straighteningError*straighteningKpLeft;
			};
		} else { //otherwise, just set the right side to the power
			rPower = power;
		}
		if (straighteningError < 0) { //right side is ahead, so speed up the left side
			lPower = power - straighteningError*straighteningKpRight;
			if (lPower > 127) {
				lPower = lPowerLast;
				rPower = power - straighteningError*straighteningKpRight;
			}
		} else { //otherwise, just set the left side to the power
			lPower = power;
		}

		//send new motor powers;
		setLDriveMotors(lPower);
		setRDriveMotors(rPower);

	}
}
}

task main()
{
	startTask(autostraighten);
	while(1) {
		if (userDriveControl) {
			setLDriveMotors(vexRT[Ch3]);
			setRDriveMotors(vexRT[Ch2]);
		}
	}


}
