#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, I2C_1,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_2,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port2,           lDriveFront,   tmotorVex393TurboSpeed_MC29, openLoop)
#pragma config(Motor,  port3,           lDriveMiddle,  tmotorVex393TurboSpeed_MC29, openLoop, encoderPort, I2C_1)
#pragma config(Motor,  port4,           lDriveBack,    tmotorVex393TurboSpeed_MC29, openLoop)
#pragma config(Motor,  port5,           rDriveBack,    tmotorVex393TurboSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port6,           rDriveMiddle,  tmotorVex393TurboSpeed_MC29, openLoop, reversed, encoderPort, I2C_2)
#pragma config(Motor,  port7,           rDriveFront,   tmotorVex393TurboSpeed_MC29, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

float positionKp = 0.33, //proportional constant for positional PID
			straighteningKpLeft = 0.43,//.195, //proportional constant for straightening response for the left side
			straighteningKpRight = 0.22,//.16, //proportional constant for straightening response for the right side
			positionKi = 0.00068, //integral constant
			positionKd = 3.75; //derivative constant

static int FORWARD = 1;
static int BACKWARD = -1;

void setLDriveMotors(float power) {
	motor[lDriveFront] = power;
	motor[lDriveMiddle] = power;
	motor[lDriveBack] = power;
}

void setRDriveMotors(float power) {
	motor[rDriveFront] = power;
	motor[rDriveMiddle] = power;
	motor[rDriveBack] = power;
}

void driveDistancePID(int encoderCounts, int direction, int time) {
	writeDebugStreamLine("nPgmTime,error,nMotorEncoder[lDriveMiddle], nMotorEncoder[rDriveMiddle],pTerm,iTerm,dTerm,lPower,rPower");
	//reset encoder values
	nMotorEncoder[rDriveMiddle] = 0;
	nMotorEncoder[lDriveMiddle] = 0;

	int error = 0,
	straighteningError = 0,
	errorSum = 0,
	lastError = 0,
	target = encoderCounts * direction,
	slewRateLimit = 13;

	float pTerm,
	iTerm,
	dTerm,
	straighteningCorrection,
	power,
	lPower,
	rPower,
	lastPower;
	time1[T1] = 0;
	if (direction == FORWARD) {
		while (time1[T1] < time) {
			//update error terms
			error = target - (nMotorEncoder[lDriveMiddle] + nMotorEncoder[rDriveMiddle])/2;
			errorSum += error;

			pTerm = error * (float) positionKp;
			iTerm = errorSum * (float) positionKi;
			dTerm = (error - lastError) * (float) positionKd; //calculate motor power
			power = pTerm + iTerm + dTerm;

			//limit the values of the power term to only be those that can be taken by the motors
			if (power > 127) {
				power = 127;
			} else if (power < -127) {
				power = -127;
			}

			lastError = error; //update last error

			//apply a slew rate to limit acceleration/deceleration
			if(abs(power-lastPower) > slewRateLimit) {
				if(power > lastPower) { //if the power is increasing (and the difference is greater than the slew rate allows)
					power = lastPower + slewRateLimit; //increment the power to only add
				} else { //if the power is decreasing (and the differene is greater than the slew rate allows)
					power = lastPower - slewRateLimit;
				}
			}

			//adjust the powers sent to each side if the encoder values don't match
			straighteningError = nMotorEncoder[lDriveMiddle] - nMotorEncoder[rDriveMiddle];

			if (straighteningError > 0) { //left side is ahead, so speed up the right side
				rPower = power + straighteningError*straighteningKpLeft;
			} else { //otherwise, just set the right side to the power
				rPower = power;
			}
			if (straighteningError < 0) { //right side is ahead, so speed up the left side
				lPower = power - straighteningError*straighteningKpRight;
			} else { //otherwise, just set the right side to the power
				lPower = power;
			}

			lastPower = power; //update the last power
			writeDebugStreamLine("%d,%f,%f,%f,%f,%f,%f,%f,%f",nPgmTime,error,nMotorEncoder[lDriveMiddle], nMotorEncoder[rDriveMiddle],pTerm,iTerm,dTerm,lPower,rPower);
			setLDriveMotors(lPower);
			setRDriveMotors(rPower);
			wait1Msec(25);
		}
	}
}

task main()
{
	driveDistancePID(600, FORWARD,6000);
}
