#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, dgtl1,  topGreenLED,    sensorLEDtoVCC)
#pragma config(Sensor, dgtl2,  bottomGreenLED, sensorLEDtoVCC)
#pragma config(Sensor, dgtl3,  yellowLED,      sensorLEDtoVCC)
#pragma config(Sensor, dgtl4,  redLED,         sensorLEDtoVCC)
#pragma config(Sensor, dgtl10, intakeLimit,    sensorTouch)
#pragma config(Sensor, dgtl11, yellowLED,      sensorNone)
#pragma config(Sensor, I2C_1,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_2,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_3,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_4,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_5,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port1,           intakeRoller,  tmotorVex393TurboSpeed_HBridge, openLoop, reversed)
#pragma config(Motor,  port2,           lFlywheel,     tmotorVex393HighSpeed_MC29, openLoop, encoderPort, I2C_1)
#pragma config(Motor,  port3,           rDriveFront,   tmotorVex393TurboSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port4,           rDriveMiddle,  tmotorVex393TurboSpeed_MC29, openLoop, reversed, encoderPort, I2C_4)
#pragma config(Motor,  port5,           rDriveBack,    tmotorVex393TurboSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port6,           lDriveBack,    tmotorVex393TurboSpeed_MC29, openLoop)
#pragma config(Motor,  port7,           rFlyTop,       tmotorVex393TurboSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port8,           rFlyBottom,    tmotorVex393TurboSpeed_MC29, openLoop, reversed, encoderPort, I2C_2)
#pragma config(Motor,  port9,           lDriveFrontMid, tmotorVex393TurboSpeed_MC29, openLoop, reversed, encoderPort, I2C_5)
#pragma config(Motor,  port10,          intakeChain,   tmotorVex393TurboSpeed_HBridge, openLoop, reversed, encoderPort, I2C_3)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

bool slow = false,
		 userIntakeControl = true;

int ballsInIntake = 0;

void setLeftFwSpeed (float power) {
	motor[lFlywheel] = power;
}

void setRightFwSpeed (float power) {
	motor[rFlyTop] = power;
		motor[rFlyBottom] = power;

}

void moveIntakeChain (int encoderCounts) {
	nMotorEncoder[intakeChain] = 0;
	while (nMotorEncoder[intakeChain] < encoderCounts) {
		motor[intakeChain] = 127;
	}
	motor[intakeChain] = 0;
}

int drive(int n)
{
	if(abs(n)<3)
	{
		return 0;
	}
	else if (slow == true)
	{
		return n/2.7;
	}
	else
	{
		return n;
	}
}

task countBallsInIntake() {
	int numConsecLimitSwitchZeros = 0; //number of consecutive zero values received from limit switch
	while(1) {

		while(!SensorValue[intakeLimit]) { //wait until the limit switch is pressed
			wait1Msec(25);
		}

		while(SensorValue[intakeLimit] || numConsecLimitSwitchZeros < 1) { //wait until the limit switch is released so we only increment/decrement ballsInIntake once per ball in the intake - allow one stray 0 value in the
			//below if statement is used to reject "false" 0 values [0 values received even when a ball is under the dangle]
			if(!SensorValue[intakeLimit]) { //if the limit switch returns 0
				numConsecLimitSwitchZeros++;	//increase the number of consecutive limit switch zero values received
			} else {
				numConsecLimitSwitchZeros = 0; //reset the number of consecutive limit switch zero values received to 0 since a 1 was received
			}
			wait1Msec(25);
		}

		//NOTE: this doesn't account for balls leaving the intake via the flywheel
		//reach this point once the intake limit switch has been pressed and then released (so balls are counted after they are done passing the dangle)
		//if (vexRT[Btn6U]) { //if the roller is moving forward
		//	ballsInIntake++; //increment the number of balls in the intake
		//} else if (vexRT[Btn6D]) { //if the roller is moving backwards
			ballsInIntake--; //decrement the number of balls in the intake
		//}

	}
}

task autoIntake() {
	while(1) {
		if(SensorValue[intakeLimit] && !vexRT[Btn5D] && ballsInIntake < 3) { //if the intake limit is pressed
			userIntakeControl = false;
			moveIntakeChain(450);
			userIntakeControl = true;
			while(SensorValue[intakeLimit]) { //wait until the intake limit switch is no longer pressed so that the moveIntakeChain command doesn't run multiple times
				wait1Msec(75);
			}
		} else {
			userIntakeControl = true;
		}
		wait1Msec(25);
	}
}

task main()
{
	startTask(autoIntake);
	startTask(countBallsInIntake);

	//userIntakeControl = false;
	//motor[intakeChain] = -127;
	//motor[intakeRoller] = -127;

	while(1)
	{
		if(vexRT[Btn8D] == 1)
		{
			if(slow == true)
			{
				slow = false;
			}
			if(slow == false)
			{
				slow = true;
			}
		}

		writeDebugStreamLine("%d,%d",SensorValue[intakeLimit],ballsInIntake);

		motor[rDriveFront] =
		motor[rDriveMiddle] =
		motor[rDriveBack] =
		drive(vexRT[Ch2]);

		motor[lDriveFrontMid] =
		motor[lDriveBack] =
		drive(vexRT[Ch3]);

		if (vexRT[Btn7D]) {
			setLeftFwSpeed(70);
			setRightFwSpeed(70);
			ballsInIntake = 0;
		} else if (vexRT[Btn8R]) {
			setLeftFwSpeed(0);
			setRightFwSpeed(0);
		}

		if (userIntakeControl) {
			motor[intakeChain] = vexRT[Btn5U]*125 - vexRT[Btn5D]*125;
			motor[intakeRoller] = vexRT[Btn6U]*125 - vexRT[Btn6D]*125;
		}
		wait1Msec(25);
	}



}
