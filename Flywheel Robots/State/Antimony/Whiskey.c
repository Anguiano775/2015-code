#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in1,    gyro,           sensorGyro)
#pragma config(Sensor, dgtl9,  redLED,         sensorLEDtoVCC)
#pragma config(Sensor, dgtl10, sonar,          sensorSONAR_mm)
#pragma config(Sensor, dgtl12, led,            sensorLEDtoVCC)
#pragma config(Sensor, I2C_1,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_2,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port1,           bottomIntake,  tmotorVex393HighSpeed_HBridge, openLoop, reversed)
#pragma config(Motor,  port2,           lFlywheel,     tmotorVex393HighSpeed_MC29, openLoop, reversed, encoderPort, I2C_2)
#pragma config(Motor,  port3,           RFDrive,       tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port4,           RMDrive,       tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port5,           RBDrive,       tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port6,           LBDrive,       tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port7,           LMDrive,       tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port8,           LFDrive,       tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port9,           rFlywheel,     tmotorVex393HighSpeed_MC29, openLoop, reversed, encoderPort, I2C_1)
#pragma config(Motor,  port10,          topIntake,     tmotorVex393_HBridge, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX)

//Competition Control and Duration Settings
#pragma competitionControl(Competition)
#pragma autonomousDuration(20)
#pragma userControlDuration(120)

#include "..\..\..\Vex_Competition_Includes_No_LCD.c"   //Main competition background code...do not modify!
#include "..\..\..\LCD Autonomous Play Selection.c"
#include "..\Global\Simple PID Controller.h"

fw_controller lFly, rFly;
string str;
float flywheelMode = 0; //0 - stopped, 0.5 - stopping, 1 - close, 2 - center, 3 - purple, 4 - long
#define FORWARD 1;
#define BACKWARD -1;


void setIntakeMotors (float power) {
	motor[topIntake] = power;
	motor[bottomIntake] = power;
}

task flashLED() {
	while(1) {
		SensorValue[led] = true;
		wait1Msec(320);
		SensorValue[led] = false;
		wait1Msec(320);
	}
}


void pre_auton()
{
	// Set bStopTasksBetweenModes to false if you want to keep user created tasks running between
	// Autonomous and Tele-Op modes. You will need to manage all user created tasks if set to false.
	bStopTasksBetweenModes = true;
}

void setLeftFwSpeed (float power) {
	motor[lFlywheel] = power;
}

void setRightFwSpeed (float power) {
	motor[rFlywheel] = power;
}
task autonomous()
{
}
/*-----------------------------------------------------------------------------*/
/** @brief     Task to control the velocity of the left flywheel               */
/*-----------------------------------------------------------------------------*/
task leftFwControlTask()
{
	fw_controller *fw = lFly;

	// We are using Speed geared motors
	// Set the encoder ticks per revolution
	fw->ticks_per_rev = fw->MOTOR_TPR;

	while(1)
	{
		// debug counter
		fw->counter++;

		// Calculate velocity
		getEncoderAndTimeStamp(lFlywheel,fw->e_current, fw->encoder_timestamp);
		FwCalculateSpeed(fw);

		// Set current speed for the tbh calculation code

		fw->v_current = getMotorVelocity(lFlywheel);
		fw->current = fw->v_current;

		// Do the velocity TBH calculations
		FwControlUpdateVelocityTbh( fw ) ;

		// Scale drive into the range the motors need
		fw->motor_drive  = fw->drive * (FW_MAX_POWER/127);

		// Final Limit of motor values - don't really need this
		if( fw->motor_drive >  127 ) fw->motor_drive =  127;
		if( fw->motor_drive < -127 ) fw->motor_drive = -127;

		// and finally set the motor control value
		//if(fw->current < fw->target - 20) {
		//	setLeftFwSpeed( 70 );
		//} else
		setLeftFwSpeed(fw->motor_drive);
		str = sprintf( str, "%4d %4d  %5.2f", fw->target,  fw->current, nImmediateBatteryLevel/1000.0 );
		displayLCDString(0, 0, str );
		str = sprintf( str, "%4.2f %4.2f ", fw->drive, fw->drive_at_zero );
		displayLCDString(1, 0, str );
		// Run at somewhere between 20 and 50mS
		wait1Msec( FW_LOOP_SPEED );
	}
}

/*-----------------------------------------------------------------------------*/
/** @brief     Task to control the velocity of the right flywheel              */
/*-----------------------------------------------------------------------------*/
task rightFwControlTask()
{
	fw_controller *fw = rFly;

	// We are using Speed geared motors
	// Set the encoder ticks per revolution
	fw->ticks_per_rev = fw->MOTOR_TPR;

	while(1)
	{
		// debug counter
		fw->counter++;

		// Calculate velocity
		getEncoderAndTimeStamp(rFlywheel,fw->e_current, fw->encoder_timestamp);
		FwCalculateSpeed(fw);

		// Set current speed for the tbh calculation code
		fw->current = fw->v_current;

		// Do the velocity TBH calculations
		FwControlUpdateVelocityTbh( fw ) ;

		// Scale drive into the range the motors need
		fw->motor_drive  = fw->drive * (FW_MAX_POWER/127);

		// Final Limit of motor values - don't really need this
		if( fw->motor_drive >  127 ) fw->motor_drive =  127;
		if( fw->motor_drive < -127 ) fw->motor_drive = -127;

		// and finally set the motor control value
		//if(fw->current < fw->target - 20) {
		//	setRightFwSpeed( 70 );
		//} else
		setRightFwSpeed( fw->motor_drive );

		// Run at somewhere between 20 and 50mS
		wait1Msec( FW_LOOP_SPEED );
	}
}

//long shooting
void initializePIDLong() {
	//tbhInit(lFly, 392, 0.6, 0.008064, 0, 70); //initialize PID for left side of the flywheel
	//tbhInit(rFly, 392, 0.55, 0.008064, 0, 70); //initialize PID for right side of the flywheel
	//note the order of the parameters:
	//(controller, motor ticks per rev, KpNorm, KpBallLaunch, Ki, Kd, constant, RPM drop on ball launch)
	tbhInit(lFly, 392, 0.5821, 9.41, 0.006481, 0, 70, 20); //initialize PID for left side of the flywheel //left side might be able to have a higher P
	tbhInit(rFly, 392, 0.5821, 9.41, 0.006481, 0, 70, 20); //initialize PID for right side of the flywheel //x.x481
	startTask(leftFwControlTask);
	startTask(rightFwControlTask);
}

//short shooting
void initializePIDShort() {
	//note the order of the parameters:
	//(controller, motor ticks per rev, KpNorm, KpBallLaunch, Ki, Kd, constant, RPM drop on ball launch)
	tbhInit(lFly, 392, 0.1281, 3, 0.005081, 0, 50, 20); //initialize PID for left side of the flywheel //left side might be able to have a higher P
	tbhInit(rFly, 392, 0.1281, 3, 0.005081, 0, 50, 20); //initialize PID for right side of the flywheel //x.x481
	startTask(leftFwControlTask);
	startTask(rightFwControlTask);
}

//purple shooting (for skills)
void initializePIDPurple() {
	//note the order of the parameters:
	//(controller, motor ticks per rev, KpNorm, KpBallLaunch, Ki, Kd, constant, RPM drop on ball launch)
	tbhInit(lFly, 392, 0.4281, 3.03, 0.005481, 0, 55, 20); //initialize PID for left side of the flywheel //left side might be able to have a higher P
	tbhInit(rFly, 392, 0.4281, 3.03, 0.005481, 0, 55, 20); //initialize PID for right side of the flywheel //x.x481
	startTask(leftFwControlTask);
	startTask(rightFwControlTask);
}

task stopFlywheel() {
	//in order to continuing monitoring RPM after the flywheel is stopped (to prevent balls from being shot when the flywheel is not spinning fast enough to shoot them out of the robot),
	//  the flywheel is stopped using a special instace of the PIC controller, which will monitor flywheel RPM until it reaches 5 and then shutdown the flywheel motors completely)
	//  This is structured such that starting the flywheel will immediately override anything this task does.
	while(1) {
		if(flywheelMode == 0.5) { //trigger this by changing the value of flywheelMode to 0.5 rather than using a function call
			//stop the flywheel tasks so we can restart them with our new controllers
			stopTask(leftFwControlTask);
			stopTask(rightFwControlTask);

			//create the new controllers.  Both P constants are high so that the motor value ends up being 0 (KpBallShot is the same as KpNorm so that the P constant has a constant value regardless of whether the controller thinks a ball has been shot [or if a ball has actually been shot])
			tbhInit(lFly, 392, 1, 1, 0, 0, 0, 20); //initialize PID for left side of the flywheel //left side might be able to have a higher P
			tbhInit(rFly, 392, 1, 1, 0, 0, 0, 20); //initialize PID for right side of the flywheel //x.x481

			//restart the flywheel tasks with these new controllers
			startTask(leftFwControlTask);
			startTask(rightFwControlTask);
			FwVelocitySet(lFly, 0, 0);
			FwVelocitySet(rFly, 0, 0);

			//wait for the flywheels to have a velocity <= 5 RPM (for this only one side needs to meet this condition since the sides are mechanically linked)
			while ((lFly.current > 5 || rFly.current > 5) && flywheelMode == 0.5) {
				//wait to continue
				wait1Msec(25);
			}

			//the above while loop can be exited for one of two reasons:
			//  1. flywheel velocity on one side drops below 5 RPM
			//  2. flywheel mode changes (i.e., the user selects a new flywheel mode [close, purple, or long]
			//In case 1, we can stop the flywheel completely.  In case 2, we need to stop the flywheel stop process and start the flywheel back up (starting the flywheel is
			//  handled in the usercontrol task).
			if (flywheelMode == 0.5) { //only shutdown the flywheel if the user hasn't restarted the flywheel
				//return to open-loop control so we can control the flywheel motor powers
				stopTask(leftFwControlTask);
				stopTask(rightFwControlTask);

				//turn off the flywheel motors
				setLeftFwSpeed(0);
				setRightFwSpeed(0);

				flywheelMode = 0; //make sure we know that the flywheel is fully stopped
			}
		}
		wait1Msec(25); //don't overload the cpu
	}
}
bool slow = false;
int square(int n)
{
	int sq;
	sq = n*n;
	if(n < 0)
	{
		sq = -sq;
	}
	return sq;
}
int curve(int n)
{
	int outputPower = (square(n))/127;
	int minPower = 20;
	if(abs(n) > 3 && abs(outputPower) <= minPower)
	{
		return sgn(n)*minPower ;
	}
	else
	{
		return outputPower;
	}
}
int drive(int n)
{
	if(abs(n)<3)
	{
		return 0;
	}
	else if (slow == true)
	{
		return n/2.7;
	}
	else
	{
		return n;
	}
}
task usercontrol()
{
		//initializePIDLong();
		//FwVelocitySet(lFly,138,.7);
		//FwVelocitySet(rFly,138,.7);
	while(1)
	{


		if(vexRT[Btn8D] == 1)
		{
			if(slow == true)
			{
				slow = false;
			}
			if(slow == false)
			{
				slow = true;
			}
		}

		motor[RFDrive] =
		motor[RMDrive] =
		motor[RBDrive] =
		drive(vexRT[ch2]);
		motor[LFDrive] =
		motor[LMDrive] =
		motor[LBDrive] =
		drive(vexRT[ch3]);
		motor[topIntake] = ((vexRT[Btn5U] - vexRT[Btn5D])*127);
		motor[bottomIntake] = ((vexRT[Btn6U] - vexRT[Btn6D])*127);
	}
}
