#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, dgtl3,  readyLED,       sensorLEDtoVCC)
#pragma config(Sensor, I2C_1,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_2,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Motor,  port1,           intake1,       tmotorVex393_HBridge, openLoop)
#pragma config(Motor,  port2,           Fly1,          tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port3,           Fly2,          tmotorVex393_MC29, openLoop, reversed, encoderPort, I2C_1)
#pragma config(Motor,  port4,           Fly3,          tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port5,           rightDrive,    tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port6,           leftDrive,     tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port7,           Fly4,          tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port8,           Fly5,          tmotorVex393_MC29, openLoop, encoderPort, I2C_2)
#pragma config(Motor,  port9,           Fly6,          tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port10,          intake2,       tmotorVex393_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//This code is for testing acceleration with encoders and is designed to be used with robot connected to computer.
//If the encoders aren't connected to the robot, just put an axle and turn the axle yourself.  You can check the
//debug stream to see your RPM values as calculated by the program, along with the RPM values the program
//is expecting.

//constants
float LCLICKS_PER_REV = 606; //default = 627.2 for IME, 360 for quadrature encoders
float RCLICKS_PER_REV = 623;
//float CLICKS_PER_METER = ;
bool flywheelRunning = false; //global variable to keep track of flywheel status - this will allow us to prevent the acceleration function from being called more than once

void setLeftSpeed (float speed) //sets speed of left flywheel
{
	motor[Fly1] = speed;
	motor[Fly2] = speed;
	motor[Fly3] = speed;
	SensorValue[readyLED] = true;
}

void setRightSpeed (float speed) //sets speed of right flywheel
{
	motor[Fly4] = speed;
	motor[Fly5] = speed;
	motor[Fly6] = speed;

}

float rpmToMotorPower (float rpm) { //function to convert RPM values to a motor power; for flywheel acceleration function to convert a starting RPM to an initial motor power
	return rpm/100*127; //reverse of calculation for motor speed to RPM
}

//check if both RPMs are in the range required to make a shot
void checkLED (float lRPM, float rRPM) {
	if (lRPM >= 88 && lRPM <= 91 && rRPM >= 79 && rRPM <= 82) {
		SensorValue[readyLED] = true; //turn on the ready (green LED)
	}
	else {
		SensorValue[readyLED] = false; //turn off ready (green) LED if RPM is out of range
	}
}

void accelerateFlywheel (float targetSpeed) //gradually increases speed of flywheel
{
	/*while we need to accelerate
	get the current motor speed
	if speed < desired speed
	increase motor power by 10 or (desired speed - speed if that is less than 10)
	continue when motor power = new target speed*/
	flywheelRunning = true;
	clearTimer(T1);
	bool accelerateOn = true;
	float leftEncVal;
	float rightEncVal;
	float leftRPM;
	float rightRPM;
	float lSpeed;
	float rSpeed;
	float targetlRPM = 0;
	float targetrRPM = 0;
	bool lAtTarget = false;
	bool rAtTarget = false;
	float calcSpeed;
	float accelSpeed;
	float lRPMDiff;
	float rRPMDiff;
	float lPrevRPM = 0;
	float rPrevRPM = 0;
	float powerCompensation;
	//accelerateOn = (vexRT[Btn5D] == 1) ? true : false; //use joystick button to control acceleration (turn flywheels on/off)
	accelerateOn=true;
	clearLCDLine(0);
	clearLCDLine(1);
	//displayLCDString(0, 0, "L: ");
	//displayLCDString(1, 0, "R: ");

	//get an initial RPM estimate so that if the flywheel has already been started, the acceleration process can continue there; we can't use a variable for this because the flywheel will decelerate as soon as it is no longer receiving power
	nMotorEncoder[Fly2] = 0;
	nMotorEncoder[Fly5] = 0;
	wait1Msec(250); //250ms data capture period
	leftEncVal = abs(nMotorEncoder[Fly2]); //record the distance recorded by the encoder in the 500 ms period; take the absolute value so counting direction is irrelevant
	rightEncVal = abs(nMotorEncoder[Fly5]);

	//approximate flywheel RPM values using the encoder readings
	leftRPM = (leftEncVal/LCLICKS_PER_REV*240); //dimensional analysis to convert encoder values to RPM using values for the motors we're using		rightRPM = (rightEncVal/RCLICKS_PER_REV*240)/7;
	rightRPM = (rightEncVal/RCLICKS_PER_REV*240);
	//writeDebugStreamLine("Estimated starting left RPM is %d for target %d",leftRPM,lSpeed);
	//writeDebugStreamLine("Estimated starting right RPM is %d for target %d",rightRPM,rSpeed);

	float lRawSpeed = rpmToMotorPower(leftRPM);
	float rRawSpeed = rpmToMotorPower(rightRPM);

	if(lRawSpeed >= 40) { //check if rawSpeed is greater than the mininum required speed to start the flywheel of 25
		lSpeed = lRawSpeed - floor(lRawSpeed) > .5 ? ceil(lRawSpeed) : floor(lRawSpeed); //round the raw speed to the nearest integer to make calculations a little simpler
	}
	else {
		lSpeed = 40;
	}

	if(rRawSpeed >= 40) { //check if rawSpeed is greater than the mininum required speed to start the flywheel of 25
		rSpeed = rRawSpeed - floor(rRawSpeed) > .5 ? ceil(rRawSpeed) : floor(rRawSpeed);  //round the raw speed to the nearest integer to make calculations a little simpler
	}
	else {
		rSpeed = 40;

	}
	targetlRPM = lSpeed/127*100; //convert motor speed to RPM target - RPM must meet this in order for the acceleration to continue to the next stage
	targetrRPM = rSpeed/127*100;

	while(accelerateOn) { //the outer while loop ensures that flywheels continue running once they are up to speed

		while((!lAtTarget || !rAtTarget) && accelerateOn) //only accelerate if the appropriate button on the joystick is pressed and at least one side is not up to speed
		{
			//accelerateOn = (vexRT[Btn5D] == 1) ? true : false; //use joystick button to control acceleration (turn flywheels on/off)
			setLeftSpeed(lSpeed); //set flywheel speed to latest calculated value
			setRightSpeed(rSpeed);

			//determine how far each side of the flywheel has traveled in 1 sec, so we can approximate RPM
			nMotorEncoder[Fly2] = 0;
			nMotorEncoder[Fly5] = 0;
			wait1Msec(250); //250ms data capture period
		  leftEncVal = abs(nMotorEncoder[Fly2]); //record the distance recorded by the encoder in the 500 ms period; take the absolute value so counting direction is irrelevant
			rightEncVal = abs(nMotorEncoder[Fly5]);

			//approximate flywheel RPM values using the encoder readings
			leftRPM = (leftEncVal/LCLICKS_PER_REV*240); //dimensional analysis to convert encoder values to RPM using values for the motors we're using
			rightRPM = (rightEncVal/RCLICKS_PER_REV*240);
			writeDebugStreamLine("L: %d R: %d",leftRPM,rightRPM);
			writeDebugStreamLine("Leftencval: %d rightencval: %d, RCLICKS_PER_REV = %d",leftEncVal,rightEncVal,RCLICKS_PER_REV);
			checkLED(leftRPM,rightRPM); //if current RPM values are in range, the LED will turn on; the placement of this function call should be pretty good because if the RPM is within range, the flywheels shouldn't be adjusting much

			//check RPM difference to determine when a ball passes through the flywheel and compensate
			lRPMDiff = leftRPM - lPrevRPM;
			rRPMDiff = rightRPM - rPrevRPM;
			writeDebugStreamLine("lRPMDiff = %d, rRPMDiff = %d",lRPMDiff, rRPMDiff);
			//store the current RPM for the next iteration's calculation
			lPrevRPM = leftRPM;
			rPrevRPM = rightRPM;

			if(abs(lRPMDiff) >= 4 && abs(lRPMDiff) <= 12) { //difference of 8 will indicate a ball launch
				writeDebugStreamLine("Ball launch detected");
			}

			//change motor speed as needed for each side
			writeDebugStreamLine("Left RPM is %d before if check; targetlRPM is %d, lSpeed is %d, targetSpeed is %d",leftRPM,targetlRPM,lSpeed,targetSpeed);
			if(leftRPM >= targetlRPM*.8 && lSpeed < targetSpeed) //if the left side is 70% done accelerating from previous loop (90% adds an error tolerance) and is below target speed
			{
				calcSpeed = ((targetSpeed-(lSpeed-40))/targetSpeed)*15;
				accelSpeed = calcSpeed > 10 ? calcSpeed : 10;
				lSpeed += calcSpeed; //increase the target speed - either by 5 or the difference between the current and the target speeds
				targetlRPM = lSpeed/127*100; //calculate new target RPM
				writeDebugStreamLine("Calculated new goal RPM value for left side: %d for speed %d",targetlRPM,lSpeed);
			}
			else if(lSpeed == targetSpeed){
				lAtTarget = true; //this indicates that the left flywheel has reached its target speed
				writeDebugStreamLine("Left side reached target");
			}

			writeDebugStreamLine("Right RPM is %d before if check; targetrRPM is %d, rSpeed is %d, targetSpeed is %d",rightRPM,targetrRPM,rSpeed,targetSpeed);
			if(rightRPM >= targetrRPM*.8 && rSpeed < targetSpeed) //if the right side is 70% done accelerating from previous loop (90% adds an error tolerance) and is below target speed
			{
				calcSpeed = ((targetSpeed-(rSpeed-40))/targetSpeed)*15;
				accelSpeed = calcSpeed > 10 ? calcSpeed : 10;
				rSpeed += calcSpeed; //increase the target speed - either by 5 or the difference between the current and the target speeds
				targetrRPM = rSpeed/127*100; //calculate new target RPM
				writeDebugStreamLine("Calculated goal RPM value for right side: %d for speed %d",targetrRPM,rSpeed);
			}
			else if (rSpeed == targetSpeed) {
				rAtTarget = true;
				//writeDebugStreamLine("Right side reached target");
			}
			if(vexRT[Btn7D] == 1 && vexRT[Btn8D] == 1) { //stop accelerating if the button is released and reset variables
			  accelerateOn = false;
			  flywheelRunning = false;
			  setLeftSpeed(0);
			  setRightSpeed(0);
		}

	}
		displayLCDCenteredString(0, "Done");
	}

}

//for flywheel acceleration; the separate task lets the acceleration code run concurently with other robot functions
task accelerate() {
	while(1)
	{
		if(/*vexRT[Btn5D] == 1 &&*/ !flywheelRunning)
		{
			accelerateFlywheel(77);
		}
		//no else statement needed because the acceleration code looks for when it needs to stop itself
	}
}
task main()
{
	startTask(accelerate); //controls flywheel acceleration so that the flywheel can accelerate concurrently with drivetrain and intake motors

	clearLCDLine(0);
	clearLCDLine(1);
	bLCDBacklight = true;

	while(true)
	{
		//drivetrain
		motor[leftDrive] = vexRT[Ch3];
		motor[rightDrive] = vexRT[Ch2];

		//intake
		if(vexRT[Btn6U] == 1)
		{
			motor[intake1] = 125;
			motor[intake2] = 125;
		}
		else if(vexRT[Btn6D] == 1)
		{
			motor[intake1] = -125;
			motor[intake2] = -125;
		}
		else
		{
			motor[intake1] = 0;
			motor[intake2] = 0;
		}
	}
}
