#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, dgtl12, led,            sensorLEDtoVCC)
#pragma config(Sensor, I2C_1,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_2,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Motor,  port6,           rFlyTop,       tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port7,           rFlyBottom,    tmotorVex393_MC29, PIDControl, encoderPort, I2C_2)
#pragma config(Motor,  port8,           lFlyTop,       tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port9,           lFlyBottom,    tmotorVex393_MC29, PIDControl, reversed, encoderPort, I2C_1)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//test program to enable PID with default constants for Paper Flywheel
int waitTime = 1000;
task ledFlash() {
	while(1) {
		SensorValue[led] = true;
		wait1Msec(waitTime);
		SensorValue[led] = false;
		wait1Msec(waitTime);
	}
}

int speed = 80;
task main()
{
	slaveMotor(lFlyTop, lFlyBottom);
	slaveMotor(rFlyTop, rFlyBottom);
	startTask(ledFlash);
	motor[lFlyBottom] = speed;
	motor[rFlyBottom] = speed;
	while(1) {
		//if(vexRT[Btn5D] == 1)
		//{
	//set the other motor to follow the motor with PID activated
	//slaveMotor(topMotor, bottomMotor);
		//motor[lFlyBottom] = speed;
		//motor[rFlyBottom] = speed;
		/*}
		else {
			motor[lFlyTop] = 0;
		motor[lFlyBottom] = 0;
		motor[rFlyTop] = 0;
		motor[rFlyBottom] = 0;
	}*/
	}
}
